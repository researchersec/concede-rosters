<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate Rosters</title>
</head>
<body>
    <!-- Button to Generate Rosters -->
    <button id="generateBtn">Generate Rosters</button>
    <input type="number" id="numRosters" name="numRosters" min="1" placeholder="Number of Rosters" value="1">

    <!-- Display Rosters -->
    <div id="rosters"></div>

    <!-- JavaScript to Load Data, Generate and Display Rosters -->
    <script>
    document.getElementById('generateBtn').addEventListener('click', async function() {
        const numRosters = document.getElementById('numRosters').value || 1;

        // Load the player data from the uploaded JSON file
        const response = await fetch('players.json');
        const players = await response.json();

    function generateRosters(players, numRosters) {
    const tank_classes = ['Prot Warrior', 'Prot Paladin', 'Feral Druid Tank', 'Blood DK Tank'];
    const healer_classes = ['Holy Paladin', 'Disc Priest', 'Holy Priest', 'Resto Druid', 'Resto Shaman'];

    let rosters = [];

    for (let i = 0; i < numRosters; i++) {
        let roster = [];
        let local_added_players = new Set();  // This set keeps track of players that have been added to the current roster
        let local_added_classes = new Set();  // This set keeps track of classes that have been added to the current roster

        // Separate players into tanks, healers, and dps for each roster generation
        let tanks = players.filter(player => tank_classes.includes(player.class));
        let healers = players.filter(player => healer_classes.includes(player.class));
        let dps = players.filter(player => !tank_classes.includes(player.class) && !healer_classes.includes(player.class));

        while (roster.length < 2 && tanks.length > 0) {
            const tank = tanks.shift();
            if (!local_added_players.has(tank.name) && (!local_added_classes.has(tank.class) || tanks.length == 0)) {
                roster.push(tank);
                local_added_players.add(tank.name);
                local_added_classes.add(tank.class);
            }
        }

        while (roster.length < 4 && healers.length > 0) {
            const healer = healers.shift();
            if (!local_added_players.has(healer.name) && (!local_added_classes.has(healer.class) || healers.length == 0)) {
                roster.push(healer);
                local_added_players.add(healer.name);
                local_added_classes.add(healer.class);
            }
        }

        while (roster.length < 10 && dps.length > 0) {
            const dp = dps.shift();
            if (!local_added_players.has(dp.name) && (!local_added_classes.has(dp.class) || dps.length == 0)) {
                roster.push(dp);
                local_added_players.add(dp.name);
                local_added_classes.add(dp.class);
            }
        }

        // Shuffle the roster
        roster = roster.sort(() => Math.random() - 0.5);

        // Add the roster to the list of rosters
        rosters.push(roster);
    }

    return rosters;
}

        // Call the function to generate rosters and pass the players data and numRosters
        const rosters = generateRosters(players, numRosters);

        // Display the rosters in the 'rosters' div
        const rostersDiv = document.getElementById('rosters');
        rostersDiv.innerHTML = ''; // Clear previous rosters
        rosters.forEach((roster, index) => {
            const rosterDiv = document.createElement('div');
            rosterDiv.innerHTML = `<h2>Roster ${index + 1}</h2>`;
            roster.forEach(player => {
                rosterDiv.innerHTML += `<p><img src="${player.url}"/> Name: ${player.name}, Class: ${player.class}</p>`;
            });
            rostersDiv.appendChild(rosterDiv);
        });
    });
</script>

</body>
</html>
